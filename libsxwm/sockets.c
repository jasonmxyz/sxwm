/*
 * This file contains functions relating to the socket connection between a
 * client and the SXWM window manager.
 */

#include "handles.h"

#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <unistd.h>

 /*
 * Determine the default location of the SXWM socket. Write the path in the
 * destination buffer up to 108 bytes.
 *
 * We combine the name of the default display (from the DISPLAY environment
 * variable) with constant strings to make /tmp/sxwm:X.sock.
 *
 * On success returns the length of the string written in the buffer,
 *                    including the terminating null byte.
 * On failure returns -1 and sets errno to indicate the error.
 *
 * Errors:
 *  ENAMETOOLONG: The calculated name would not fit in a 108 byte buffer.
 *  EINVAL: The environment variable DISPLAY is not set.
 */
int SXWMDefaultSocketPath(char *buffer)
{
	char *displayName = getenv("DISPLAY");
	if (!displayName) {
		errno = EINVAL;
		return -1;
	}
	int displayNameLen = strlen(displayName);
	if (displayNameLen > 93) {
		errno = ENAMETOOLONG;
		return -1;
	}

	memcpy(buffer, "/tmp/sxwm", 9);
	memcpy(buffer + 9, displayName, displayNameLen);
	strcpy(buffer + 9 + displayNameLen, ".sock");

	return 15 + displayNameLen;
}

/*
 * Create a connection to SXWM at the specified path (or the default path) and
 * return a handle for the connection. This handle should be used in calls to
 * subsequent libsxwm functions.
 *
 * On success returns a positive handle.
 * On failure returns 0 and sets errno to indicate the error.
 *
 * Errors:
 *  ENAMETOOLONG: The calculated name would not fit in a 108 byte buffer.
 *  EINVAL: The environment variable DISPLAY is not set.
 * Other errors may be generated by socket(2), connect(2), and
 * SXWMRegisterHandle.
 */
SXWMHandle SXWMConnectSocket(const char *path)
{
	struct sockaddr_un sock;
	sock.sun_family = AF_UNIX;

	if (path) {
		/* The sockaddr_un.sun_path is 108 bytes long, we can therefore
		 * only fit 107 bytes. */
		int len = strlen(path);
		if (len > 107) {
			errno = ENAMETOOLONG;
			return -1;
		}

		strcpy(sock.sun_path, path);
	} else {
		/* Choose the default name if none is given. */
		if (SXWMDefaultSocketPath(sock.sun_path) < 0) {
			return -1;
		}
	}

	/* Create and connect the socket. */
	int fd = socket(AF_UNIX, SOCK_STREAM, 0);
	if (fd < 0) {
		return -1;
	}
	if (connect(fd, (struct sockaddr*)&sock, sizeof(struct sockaddr_un))) {
		close(fd);
		return -1;
	}

	/* Create the handle entry. */
	union sxwm_handle socketHandle;
	socketHandle.socket.type = SXWM_HANDLE_SOCKET;
	socketHandle.socket.fd = fd;

	/* Register the handle. */
	const union sxwm_handle *newHandle = SXWMRegisterHandle(&socketHandle);
	if (!newHandle) {
		close(fd);
		return -1;
	}

	/* Return the handle identifier. */
	return newHandle->any.handle;
}

/*
 * Get the socket file descriptor given a SXWMHandle.
 *
 * Gets data associated with the handle with the internal SXWMGetHandle
 * function, checks that the returned handle data is of the SXWM_HANDLE_SOCKET
 * type, then returns the stored file descriptor.
 *
 * Errors:
 *  EINVAL: The given handle does not match a socket object.
 */
int SXWMSocketFD(const SXWMHandle handle)
{
	const union sxwm_handle *socketHandle = SXWMGetHandle(handle);
	if (!socketHandle) {
		/* SXWMGetHandle set errno to EINVAL. */
		return -1;
	}

	/* Check that this is a socket entry. */
	if (socketHandle->any.type != SXWM_HANDLE_SOCKET) {
		errno = EINVAL;
		return -1;
	}

	return socketHandle->socket.fd;
}